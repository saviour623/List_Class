/** NEW UPDATE
 * Update EMPTY_ARG() to (...) 
 * update EVAL_1 and EVAL_0. EVAL_0 should paste nothing: no voi* d. handle macros that depends on it for void because UNLESS_FALS* E uses it  
 * still work on error messages
 in print function: design print in such a way that it prints only the type and index to the user */

Lets transform array to be like
ARRAY(list, U(1, 2, 4), F(2.0, 3.9, 4.6), D(1.45, 2.556, 3.3))
do we will have something like
P_U check(unsigned ...)
P_F check(float ...)
if no identifier
P_1(typeof ...)


/* TODO: check for array((1, and )1,
/* idea: array to list: add items in an array to list: float[] any type at the same time e.g
DUMMY(arg, ...)
DUMMY({1, 2, 3, 4, 5, 6}, {5.6, 5.5, 7.4, 4.664});*/



/*we check for { in arg. if braces exist, we find a way to remove the final braces and paste the arguments while doing that we check for the type of the any of the arguments, and finally we paste the the finally list, the do the same for __VA_ARGS__}

you can pass in i0, to tell that all the elements are of the same type
e.g D(i0, ...)
#def i0 i, 0
 */

/** documentation:
ARRAY
array must be bounded with parenthesis and must have members
first arhument must be an object 
array must not be called with an empty argument
if two empty argumwnt will prematurely end the array
empty array will yeild warning

* ARRAY_ARGS: Recursively checks for arguments: 
1. if arguments: check for parenthesis by assertion. assertion takes three arguments, the error signal, the current argument and: if there is parenthesis the final argument goes to the next stage, else, it expands to the arguments after the current argument which would be used by the assertion for logging error. Now if the assertion is true, the parenthesis is checked for arguments using the same assertion technique above. if true, it creates an array by calling CONSTRUCT ARRAY else it expands to the post arguments for logging error.
2. else if the current argument is empty: if the next argument has values, an error is raised for initializing an empty array. else the  end of array creation.
 
*/


/* Type Scope
if only parenthesis, deyermine type
 TYPE_N_ARGS now paste 1 for parenthesis(auto type)  or Others for specified types and zero for non recognized. but we want them to pass in their type and also themselves (for specified types like U(1) should pass only the parenthesis) and 0 should still pass 0 and its argument for error checking 
for parenthesis is done
TODO: do for type: if type is 0 dont put any parenthesis around type  else put */

/* to finally paste yhe type we might do something like 
 * TYPE(1) ... and it will expand to TYPE_1 which maybe int
 */
/** __auto_type;
struct { ##type xp;}
  sizeof(int[])
union foo u;
/* … 
u = (union foo) x  ≡  u.i = x
u = (union foo) y  ≡  u.d = y

union foo u;
/* … 
u = (union foo) x  ≡  u.i = x
u = (union foo) y  ≡  u.d = y

a* Prototype. 
inline void foo (const char) __attribute__((always_inline))
*/

/* todo write doc on if_true_eval_and repeat_array
ARRAY(u(1, 2, 3), str(1, 3), uc(5, 6), ul(6, 7))
ARRAY(U(1, 2, 3), S(1, 3), UC(5, 6), UL(6, 7))

 always call with the type striped 
how can we strip a type and still check if its a real type 
also check if its not attached 
have another implementation that also provides size
*/

/* Todo: parathesis error is not passing va_args check and fix*/
/* can we merge array and add2elements together? */
   /* Group arguments: Write array in such a way that instead of\
    * creating array it takes them as group and adds them to list
    * one after the order e.g G(1, 2, 3) list = 1 list = 2 list
    * = 3, even with specified type UG(1, 2, 3), therefore, also provide the size */
/* characters are promoted to int */
/* Remember: in expansion of variable arguments separed with commas cpp can on choose 1 argument at a time i.e 1, 2, 3, 4, 5, 6 will only expand to 1 in something like A(...) __VA_ARGS__ or something like A(A, B) A, B = A
/* Todo: REMOVE ALL INLINE MACRO COMMENTS */
/*END */
/* passing -, ., /, {, [, etc would result to error since cpp can tokenize them


list(list.self, "hold", "h", "b", "sigh", "be", "please", "yep");
  autolist(list.self, ("hold", "assert"), (1, 2, 3, 5, 8, 12, 6));
  autolist(list.self, S("hold", "assert"), U(1, 2, 3, 5, 8, 12, 6));
  arraylist(list.self, ("parcel", "carriage", "stance"));

  list.add(list.self, "yes");
  list.item(list.self);
  list.join(list.self, new.self);
  list.pop(list.self, index);
  list.push(list.self, data, index);
  list.popinfo(list.self, index);
  list.assigntotype(list.self, type);
  list.sort(list.self); //only for specific type 
  destroylist(mylist);

  assign(index);
  /* would call init with 
  list->add(1, 2);

  //AUTO_TYPE(group, 2, 1, 1, int, 5, 6, 7, 8, 9, 5, 5, 6, 7, 8, 9, 5, 5, 6, 7, 8, 9, 5);



/***
void print_list(Object_List *self){
  //TODO: print_list should allow user to add specifiers like %(x, o, precision, etc for integers
  //also implement print index function;
  while (list_ptr != NULL){
#     if list_ptr->type == 1;
          typedef int32_t type;
#         define type_spec "d"
#     elif !(list_ptr->type)
#        define type_spec "f"
         typedef double type;
#     else
#       define type_spec "p"
        typedef void * type;
#     endif
  }
  printf(("%") (type_spec), (type *)(self->generic_list->data))
  } */

#endif /* GENERIC_LIST */

/** ADD FEATURES
 * remfromlist
 * (remove a particular value througout the list */
/* remove entire if no index is passed
 *
 * add2list
 * add to index
 * add to last if index is not specified

 * Assign (macro) cast data to appropriate type
 * join
 * join two list with direction eg list 1 first, list 2 second

 * print
 * printf with specification (pass format as string)
 * printf with indexes
 * printf only type (if index is specified print with index)
*/

//#define ____list_expand_param(obj, memtype, ...): we check if it is a parenthesis, check if parenhesis has members, check if parenthesis is two argument, check if there is first argument and if there is second argument, if it is not a parenthesis just paste it as obj
